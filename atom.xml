<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[For the Love of Code]]></title>
  <link href="http://hpetrow.github.io/atom.xml" rel="self"/>
  <link href="http://hpetrow.github.io/"/>
  <updated>2015-07-14T09:15:48-04:00</updated>
  <id>http://hpetrow.github.io/</id>
  <author>
    <name><![CDATA[Heather Petrow]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Me and My Arel]]></title>
    <link href="http://hpetrow.github.io/blog/2015/07/14/me-and-my-arel/"/>
    <updated>2015-07-14T06:22:49-04:00</updated>
    <id>http://hpetrow.github.io/blog/2015/07/14/me-and-my-arel</id>
    <content type="html"><![CDATA[<p>
Beneath the fantastical query interface of Active Record is a trusty little helper named Arel.
According to the documentation, Arel is a SQL AST manager for Ruby. It<br>
<ol>
  <li>Simplifies the generation of complex SQL queries</li>
  <li>Adapts to various RDBMSes</li>
</ol>
</p>




<p>
So, what does this mean, and what does Arel do beneath the surface?
</p>




<h3>The Point! Arel is an object-oriented Ruby library for relational algebra</h3>


<p>
Relational algebra is a mathematical system, in which the operands are relations (or variables representing relations), and the operators are common procedures on these relations in a database. By definition as an algabraic system, operators and operands are combined to form expressions that produce new values. So, all of the things we want to do with our database, like selecting and getting attributes, are expressed as evaluations of relations and operations. The core relational algebra operations are: set operations (union, intersection, and difference); selection (picking rows); projection (picking columns); products/ joins, and renaming. So, for example, a selection query can be mathematically fornulated as R1:= &sigma;<sub>c</sub>(R2), where c is the condition to be satisfied with reference to attributes of R2.
</p>




<h3>The Not So Pointless Forest of Abstract Syntax Trees</h3>


<p>
Arel implements this relational algebra system by representing queries as nodes in a data structure called an abstract syntax tree (AST). An abstract syntax tree is just a graph which breaks the syntax down into abstract pieces and represents their syntactic relationships as paths. What is the point of all these nodes? Having queries represented as nodes is really powerful, because it makes queries composable and allows for creation or modification through method calls. So a query can be built up modularly through combinations of parts, as well as with other queries. Like interchangable blocks, the pieces can configured to form many different results.
</p>


<p>
In the spirit of object-oriented design, this is a very Rubyist solution for managing unweildy queries, because responsibilities and logic can be separated into objects and comprehensive pieces with particular jobs and explicit names, that can be reused and chained together. Thus, complex queries become simplified into more managable parts with much more resiliance and variability. This flexibility is at the heart of Arel's functionality, but it additionally extends to the higher level ORM framework, like Active Record, which is built on top. And, so this is a really large force behind the magic of the Active Record query interface.
</p>




<p>
In this transformative story, there are three big supporting characters: the manager, the visitor, and the collector.
</p>




<h3> The Pointed Man-ager </h3>


<p>
...because "A point in every direction is the same as no point at all."<br>
Managers are objects responsible for creating and modifying the tree. For instance, The Select Manager is responsible for composing select statements. So, if we select all from a table, (table.project(Arel.star)), an instance of SelectManager is returned. Similarly, there are managers for insert, update, and delete. If we want to compose a select query, we can instantiate a manager instance (insert_manager = Arel::InsertManager.new(ActiveRecord::Base)), and tell the manager to create the query, (insert_manager.insert([[table[:attribute], "value"]])). When methods are called to modify the query, the manager goes in and updates the appropriate nodes of the tree. We can then call the to_sql method on the manager instance to have the resulting SQL statement returned.
</p>




<h3> The Leaf Visitors </h3>


<p>
Arel processes the output by using the extrinsic visitor pattern, which enables Arel to remain flexible and database agnostic. This also abstracts the output processing away from the tree, so that the structure doesn't need to change in order to produce different types of queries. There are a number of different types of visitors in the Visitor directory, but the big database workhorse is ToSql. Other visitors include, MySQL, PostgreSQL, and SQLite. And since the point of Arel is to generate SQL statements, all of the database visitors inherit from ToSql. With all of these visitors, Arel must be really smart about which visitor to use. It does this by having the visitor call an accept method on itself, with the root node as an argument. Then, it looks at the root node and determines which visit method to execute from the root node's type. So, the nodes don't need to concern themselves with results, as the leaves need not concern themselves with the harvest.
</p>




<h3> The Rock - Collector </h3>


<p>
Then, bringing it all together, is the collector. The collector is an object that gathers the results from the visitor. It's just a fancy string. For example, the collector PlainString is initialized with an @str attribute set to ''. The SQLString collector then inherits from PlainString. Within the to_sql method (which lives in the Tree Manager), the collector gets the visitor from the connection (engine.connection.visitor). Then the collector's value method is called to produce to the final result, which is the resulting SQL query.
</p>




<h3> The Point of No Return - Dot </h3>


<p>
There is also a Visitor called Dot, which will create a diagram from the Abstract Syntax Tree in Graphviz dot format. Rather than calling to_sql on the manager, we can also call to_dot, and get a pretty diagram output. So, if we have a table of boats and we want to select all the boats, we can do the following:<br>
boats = Arel::Table.new(:boats, ActiveRecord::Base)<br>
select_manager = boats.project(Arel.star)<br>
select_manager.to_sql #=> "SELECT * FROM \"boats\"" <em>(to_sql returns the expected sql)</em><br>
File.write("arel.dot", select_manager.to_dot) <em>(to_dot returns the the AST diagram)</em><br>
Then, we can convert the dot file to a png, and...
</p>


<p><img class="center" src="http://hpetrow.github.io/images/arel.png" width="350" height="350" title="image" alt="images"></p>

<p>
  <ul>
    <li>https://github.com/rails/arel</li>
    <li>http://infolab.stanford.edu/~ullman/fcdb/aut07/slides/ra.pdf</li>
    <li>http://web.info.uvt.ro/~oaritoni/inginerie/Cursuri/DesignPatterns/L7/Visitor/nordberg.ps.pdf</li>
    <li>http://jpospisil.com/2014/06/16/the-definitive-guide-to-arel-the-sql-manager-for-ruby.html</li>
  </ul>
</p>


<hr />
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Professor Butts RacksUp and Talks Middleware]]></title>
    <link href="http://hpetrow.github.io/blog/2015/06/29/professor-butts-racksup-and-talks-middleware/"/>
    <updated>2015-06-29T07:27:59-04:00</updated>
    <id>http://hpetrow.github.io/blog/2015/06/29/professor-butts-racksup-and-talks-middleware</id>
    <content type="html"><![CDATA[<p><img class="center" src="http://hpetrow.github.io/images/prof_butts.gif" width="350" height="350" title="image" alt="images">
<br>
use SpoonToMouth<br>
use JerkLadle<br>
use ThrowCrackerPastParrot<br>
use ParrotJumps<br>
use PerchTilts<br>
use SeedsInPail<br>
use PullCord<br>
use IgniteRocket<br>
use SickleCutsString<br>
use PendumlumSwings<br>
use NapkinSwings<br>
run ProfessorButtsAndTheSelfOperatingNapkin<br></p>

<p>class ProfessorButtsAndTheSelfOperatingNapkin<br>
&nbsp;&nbsp;def call(env)<br>
&nbsp;&nbsp;&nbsp;&nbsp;[200, {&ldquo;Content-Type&rdquo; => &ldquo;text/plain&rdquo;}, [&ldquo;SelfOperatingNapkin&rdquo;]]<br>
&nbsp;&nbsp;end<br>
end<br></p>

<p><strong>Professor Butts RacksUp and Talks Middleware</strong><br>
<br>
While futzing around with a recent Rack lab, I found myself feeling like I was trying to operate a manual transmission without understanding how the engine works. So, this is an attempt to bring some clarity to my understanding of Rack and how it is integrated into http facing applications.<br>
<br>
<em>Professor Butts, I don&rsquo;t get it. What is Rack?</em><br>
<br>
Rack is a middleware program that serves as an intermediary between web servers and web applications. It is an interface that provides a level of abstraction over some of the different stages of request/response handling, such as authentication, authorization, caching, and execution. At a basic level, it wraps the HTTP requests/responses into a streamlined protocol, so that the logic of application functionality doesn&rsquo;t have to mix concerns with the whole business of communication between server-application.
<br><br>
At the core of its functionality, Rack applications must simply respond to a call method that takes an evironment hash as an argument. This env arg contains data pertaining to the incoming request, such as REQUEST_METHOD; PATH_INFO, SERVER_PORT, and HTTP_VARIABLES, sort of like &hellip;the postage of on a letter? The purpose of env seemed mysterious at first, but it is really just a hash with CGI-type variables that must conform to the rack standard environment spec. Then, the outgoing response is forumulated as an array containing three items: a status, headers, and a body that must respond to an &lsquo;each&rsquo; method.
<br><br>
<em>Why middleware?</em>
<br><br>
A particularly powerful aspect of Rack lies in its use middlware. Middlware just refers to software that is&hellip; in the middle. It acts as the connection layer between interacting applications. And Rack is itself also a type of middleware - middleware upon middleware. The middleware in Rack are just Ruby classes that have an initialize method taking an application as an argument and also have a call method. They simply act as filters around the request to the application and modifiers to the response. The Rack architecture utilizes the middleware modules by building them into a stack to chain the processes in a pipeline design pattern. By separating concerns into this logical chain of modules, it distills all the steps of the task down into one simple method call.
<br><br>
class IgniteRocket<br>
&nbsp;&nbsp;def initialize(app)<br>
&nbsp;&nbsp;&nbsp;&nbsp;@app = app<br>
&nbsp;&nbsp;end<br></p>

<p>&nbsp;&nbsp;def call(env)<br>
&nbsp;&nbsp;&nbsp;&nbsp;status, headers, response  = @app.call(env)<br>
&nbsp;&nbsp;&nbsp;&nbsp;rocket_launched = &ldquo; &amp;$%#*** >==> &rdquo;<br>
&nbsp;&nbsp;&nbsp;&nbsp;[status, headers, response.last + rocket_launched]<br>
&nbsp;&nbsp;end<br>
end<br>
<br><br>
class SickleCutsString<br>
&nbsp;&nbsp;def initialize(app)<br>
&nbsp;&nbsp;&nbsp;&nbsp;@app = app<br>
&nbsp;&nbsp;end<br></p>

<p>&nbsp;&nbsp;def call(env)<br>
&nbsp;&nbsp;&nbsp;&nbsp;status, headers, response  = @app.call(env)<br>
&nbsp;&nbsp;&nbsp;&nbsp;sickle = &ldquo; &ndash;(/&ndash; &rdquo;<br>
&nbsp;&nbsp;&nbsp;&nbsp;[status, headers, response.last + sickle]<br>
&nbsp;&nbsp;end<br>
end<br>
<br><br>
<em>Pipline Processing?</em><br>
<br>
I think Rack&rsquo;s pipeline processing design may be most simply imagined as a series of sequential tasks, with the output of each stage being passed down the line. Pipeline design reminds me of a Rube Goldberg machine, with lots of little processes happening in succession. Computations are passed along the stack like a conveyer belt to configure the response. This process chain provides an organized, modular way to sift and separate the various concerns of transfer protocol, making the handling more simple and streamlined. So, without a lot of fuss, Rack gives me to power and flexibility to initiate a request with a lift of my spoon, &hellip;throw a cracker, feed a parrot, fill a pail, launch a tiny rocket into space, &hellip;and respond with a napkin in my face.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Am I Just an Instance?]]></title>
    <link href="http://hpetrow.github.io/blog/2015/06/16/am-i-just-an-instance/"/>
    <updated>2015-06-16T07:41:32-04:00</updated>
    <id>http://hpetrow.github.io/blog/2015/06/16/am-i-just-an-instance</id>
    <content type="html"><![CDATA[<p>Object-oriented programming is an elegant design pattern due to its fundamental
abstraction of logic, and the ability to encapsulate data storage and transfer
in an organized system of properties and behavior. The oo model is so beautiful
and logical because it is dependant on relationships and communication, which
mirrors some of the most powerful and efficient systems in nature, from ant
colonies to neural networks. Classes can share the same data in the form of
class methods and class variables, but instances may have unique values and
behavior through instance methods and variables. Ie. We are all humans,
@@alive = true, trying to make sense of @@life_the_universe_and_everything = 42,
but are also different and unique individuals, with different @characteristics
and @experiences.</p>

<p>In particular, object-oriented programming in Ruby is empowering and liberating,
because of the lack of authoritarian restriction sometimes present in other
languages. As a person who is loosely devout to categorization and right angles,
oop in Ruby can seem at first like the wild west of coding. Coming from some
Java experience, which tends to be strongly typed, Ruby seems at first like an
irresponsible caretaker, letting variables hang around with whomever they
choose. However, it is this freedom that enables dynamic assignment and
interaction. The programmer is liberated from fussing over types and
typecasting, focusing rather upon functionality and logical relationships. Ruby
trusts the human, because it was written for the human, and doesn&rsquo;t impose
stringent rules to chastise at every incompatible type.</p>

<p>Like many others here at Flatiron, there was a time when programming was the
last thing I would have imagined myself doing. Coding always seemed like a
mysterious realm where pedantic geniuses were permanantly hunched over machines,
typing endless lines of crytic mathematical prescience. It was such an internal
upheaval to discover this love for coding that it is still sometimes difficult
to believe. Yet I need only to call upon self.loves_to_code #=> true, to verify
its validity. Now, I can hardly imagine my life without code. I suppose fate is
a clever (rubyist) programmer.</p>

<p>It occurs to me that learning to let ourselves love something new, such as
coding, may be more difficult the more strongly we type our properties. We may
resist assigning our attributes to unknown types, because we have defined
ourselves and our variables so strictly. My Java self would have triggered an
onslaught of compile-time errors at any attempt to assign this type of
Programmer. Conversely, my Ruby self allows me to embrace new ideas and
experiences, and yet, still remain the same self. I have come to deeply
appreciate the Ruby language, because it allows me to focus on expression and
meaning, to view the self as a whole, rather than belaboring the mechanics of
every thought and decision.</p>

<p>So, if, in moments of existential crisis, I can hardly recognize this version of
self, with instance variables so different from the self that existed not so
very long ago, perhaps there is some solace in believing that perhaps I am
merely an instance with a particular object identity, taking up some
insignificant, temporal space in memory. My properties may have changed, but my
identity has not. In moments of doubt, I&rsquo;ll call upon my methods.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[My First Post on Octopress]]></title>
    <link href="http://hpetrow.github.io/blog/2015/06/14/my-first-post-on-octopress/"/>
    <updated>2015-06-14T16:05:56-04:00</updated>
    <id>http://hpetrow.github.io/blog/2015/06/14/my-first-post-on-octopress</id>
    <content type="html"><![CDATA[<p>Hello world.</p>
]]></content>
  </entry>
  
</feed>
